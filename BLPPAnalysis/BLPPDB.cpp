#include "llvm/Analysis/BLPPDB.h"
#include "llvm/Support/CommandLine.h"
#define DEBUG_BDB 1

using namespace llvm;
static cl::opt<std::string>
  sProfileData("blppdata", cl::value_desc("filename"),
  cl::desc("profile info generated by BLPP-instrumented executable"),
  cl::Hidden);

BLPPDB::BLPPDB() : FunctionPass(ID) {
  uiFnID = 0;
  assert(!sProfileData.empty());
  init(sProfileData.c_str());
}

/* This function initializes the database. It reads the header of the
	 path profile and stores it in bhP, and avoids the need to call
	 fseek each time context is set to find the offset in the profile
	 where information about the paths of a particular function is
	 stored.
	 Inputs:
	 fDBNameP -> The database file.
	 Return Value:
	 None
*/
void BLPPDB::init(const char *fDBNameP) {
	BLPPDBHdr hdr;

	fDBP = fopen(fDBNameP, "rb");
	assert(NULL != fDBP && "Can't open Path Profile");

	uiCurFnID = 0;
	fseek(fDBP, 0, SEEK_SET);
	fread(&hdr, BLPPDB_HDR_SIZE, 1, fDBP);
	uiNumFuncs = (hdr.uiOffset / sizeof(hdr));

	bhP = new BLPPDBHdr[uiNumFuncs];
	fseek(fDBP, 0, SEEK_SET);
	fread(bhP, BLPPDB_HDR_SIZE, uiNumFuncs, fDBP);

	uiNumFuncs--; /* since the last entry is actually a dummy entry */
	
}

	/* This function returns 1 iff the input function was ever executed in
		 the profile run. Otherwise it returns 0.
		 Inputs:
		   uiFnID      -> Function ID
		 Return Value:
		   1, if the function corresponding to FunctionID got executed in the
			 profile run; 0 otherwise
		 Side Effects:
		   None
	*/

unsigned int BLPPDB::was_called (unsigned int uiFnID) {
	unsigned int uiRetVal;
	if ( (uiFnID >= uiNumFuncs) || (0 == bhP[uiFnID].uiNumPaths) ) {
		uiRetVal = 0;
	} else {
		uiRetVal = 1;
	}
	return uiRetVal;
}

/* This function sets the context for the queries, which are context
	 sensitive. The context is defined by the function id and the 
	 function's CFG representation.
	 Inputs:
	 uiFnID -> ID of the function defining the context
	 cfgCurFnP -> The function's CFG representation
*/
void BLPPDB::set_context(unsigned int uiFID)
{
  uiFnID = uiFID;
}

bool BLPPDB::runOnFunction(Function &sCurFun) {
	/* Index into the header to find where the information for the 
		 function starts
	*/
	BLPPDBHdr hdr;
	BLPPProfInfo profInfo;
	AnnotatedPath apWithFreq;
	unsigned int i;
	char *scHashKeyP = new char[BLPPDB_MAX_KEY_LEN];

	#if DEBUG_BDB
	unsigned int j;
	#endif


	/* Initialize the BLPP Path Regenerator */
  BLPP &bp = getAnalysis<BLPP>();

	lSuccessorFreqP = new std::list<EdgeFreq> [sCurFun.size()];
	
	if (uiFnID < uiNumFuncs) {

		hdr = bhP[uiFnID];
		printf("Function ID: %d %d\n", hdr.uiFunctionID, uiFnID);
		printf("Offset in file: %d\n", hdr.uiOffset);
		printf("Number of paths: %d\n", hdr.uiNumPaths);
		
		/* Now index into the function info */
		fseek(fDBP, hdr.uiOffset, SEEK_SET);
		
		uiNodeFrequencyP = new uint32_t[sCurFun.size()];
		for (i = 0; i < sCurFun.size(); i++) {
			uiNodeFrequencyP[i] = 0;
		}

		/* Do for each path */
		for (i = 0; i < hdr.uiNumPaths; i++) {
			std::map<std::string, std::list<AnnotatedPath> >::iterator it;
			fread(&profInfo, sizeof(BLPPProfInfo), 1, fDBP);
			
			/* Regenerate the path */
			apWithFreq.bPath = bp.RegeneratePath(profInfo.uLPathID);
			apWithFreq.flExecFreq = profInfo.uiExecCount;

#if 0
			if ((unsigned int) -1 != uiBackEdgeTarget) {
				/* The path terminates with a back edge. Give due credits to
					 back edge too
				*/
				increment_edge_frequency
					(apWithFreq.bPath.uiVerticesP[apWithFreq.bPath.uiNumNodes - 1],
					 uiBackEdgeTarget, profInfo.uiExecCount);
			}
#endif
			
#if DEBUG_BDB
			printf("Path ID: %lu;", profInfo.uLPathID);
#endif

			for (j = 0; j < apWithFreq.bPath.uiNumNodes; j++) {

				/* One point for v[j] in the path */
				uiNodeFrequencyP[apWithFreq.bPath.bnPP[j]->uiNodeID] += 
					profInfo.uiExecCount;

				if (j != 0) {
					/* One point for edge v[j-1] to v[j] */
					increment_edge_frequency(apWithFreq.bPath.bnPP[j-1]->uiNodeID,
																	 apWithFreq.bPath.bnPP[j]->uiNodeID,
																	 profInfo.uiExecCount);
				}

#if DEBUG_BDB
				printf("%d->", apWithFreq.bPath.bnPP[j]->uiNodeID);
#endif
			}
			
#if DEBUG_BDB			
			printf("EOP:%g\n", apWithFreq.flExecFreq);
#endif
			
			
			/* Classify the path based on source and destination; Form a
				 key using <src, dest> pair
			*/
			sprintf(scHashKeyP, "%u:%u", apWithFreq.bPath.bnPP[0]->uiNodeID,
							apWithFreq.bPath.bnPP[apWithFreq.bPath.uiNumNodes - 1]->uiNodeID);
			
			/* Insert in hash table */
			it = ht.find(scHashKeyP);
			if (it != ht.end()) {
				((*it).second).push_back(apWithFreq);
			} else {
				char *scNewKeyP = new char[BLPPDB_MAX_KEY_LEN];
				strcpy(scNewKeyP, scHashKeyP);
				/* Create a new list! */
				std::list<AnnotatedPath> *lP;
				lP = new std::list<AnnotatedPath>;
				lP->push_back(apWithFreq);
				ht.insert(std::map<std::string, 
          std::list<AnnotatedPath> >::value_type(scNewKeyP, *lP));
			}
		}
		
		sort_normalize();
		delete [] scHashKeyP;	
	}

  uiFnID++;
  return false;
	/*bp.clean_context();*/ /* We have got all the information needed - Path,
												 Edge and Block Profile.
											*/
}

/* This helper function sorts paths between every pair of vertices in
	 the decreasing order of execution frequency, and normalizes
	 the execution frequency.
*/

void BLPPDB::sort_normalize() {
	for (	std::map<std::string, 
					std::list<AnnotatedPath> >::iterator it = ht.begin(); 
				it != ht.end(); it++) {
		sort((*it).second);
		normalize((*it).second);
	}
}


void sort(std::list<AnnotatedPath>& l) {
  l.sort();
}


/* Normalize Execution Frequencies */
void normalize(std::list<AnnotatedPath>& l) {

	std::list<AnnotatedPath>::iterator it1;
	float sum = 0.0;

	/* Find Sum */
 	for (it1 = l.begin(); it1 != l.end(); it1++) {
		sum += (*it1).flExecFreq;
	}

	/* Normalize */
 	for (it1 = l.begin(); it1 != l.end(); it1++) {
		(*it1).flExecFreq = (*it1).flExecFreq / sum;
	}


}




/* This function returns the list of paths between two nodes, whose
	 combined execution frequencies cross the specified threshold.
	 Inputs:
	 uiSrcNode   -> Source Node
	 uiDestNode  -> Destination
	 flExecFreq  -> Execution Frequency Threshold
	 Return Value:
	 A List of paths 
*/
std::list<BLPPPath> 
BLPPDB::get_hot_paths(unsigned int uiSrcNode,
											unsigned int uiDestNode,
											float flExecFreq) {
	
	std::list<BLPPPath> lBLPPPath;
	std::list<AnnotatedPath> lAnnotatedPath;
	std::list<AnnotatedPath>::iterator it;
	std::map<std::string, std::list<AnnotatedPath> >::iterator it1;
	char *scHashKeyP = new char[BLPPDB_MAX_KEY_LEN];
	float flCumFreq = 0.0;

	sprintf(scHashKeyP, "%u:%u", uiSrcNode, uiDestNode);
	it1 = ht.find(scHashKeyP);
	if (it1 != ht.end()) {
		assert(it1 != ht.end() && "Key not found");

		lAnnotatedPath = (*(ht.find(scHashKeyP))).second;
		
		for (it = lAnnotatedPath.begin(); (it != lAnnotatedPath.end()) &&
					 flExecFreq >= flCumFreq; it++) {
			lBLPPPath.push_back((*it).bPath);
			flCumFreq += (*it).flExecFreq;
		}
	}

	delete [] scHashKeyP;
	return lBLPPPath;
	
}

	/* This function returns the number of times, the specified BB was 
		 executed. 
		 Inputs:
		   uiNode      -> BB node number
		 Return Value:
		   Number of times the basic block was executed in the profile run
		 PreConditions:
		   The last set_context call must have been for the function in which
			 the basic block is present. That context should not have been cleared.
	*/
uint32_t BLPPDB::get_block_frequency (unsigned int uiNode) {
	return uiNodeFrequencyP[uiNode];
}

	/* This function returns the number of times, the specified edge was 
		 taken in the profile run.
		 Inputs:
		   uiSrcNode     -> source of the edge
			 uiTargetNode  -> target of the edge
		 Return Value:
		   Number of times the edge was taken in the profile run
		 PreConditions:
		   The last set_context call must have been for the function in which
			 the basic block is present. That context should not have been cleared.
	*/
	uint32_t BLPPDB::get_edge_frequency(unsigned int uiSrcNode, 
																			unsigned int uiTargetNode) {

		/* Initialize to 0 incase the edge was never executed */
		uint32_t uiFreq = 0;

		for (std::list<EdgeFreq>::iterator it = 
					 lSuccessorFreqP[uiSrcNode].begin(); it != lSuccessorFreqP[uiSrcNode].end();
				 it++) {
			if ((*it).uiTarget == uiTargetNode) {
				uiFreq = (*it).uiFreq;
			}
		}
		return uiFreq;
	}


/* This function cleans up the data structures created for the current context 
	 Inputs:
	   None
	 Return Value:
	   None
	 Side Effects:
	   Hash Table Contents are cleared; BLPPPath context is cleared.
 */


void BLPPDB::clean_context() {
	std::map<std::string, std::list<AnnotatedPath> >::iterator it;
	
	
	for (it = ht.begin(); it != ht.end(); it++) {
		std::list<AnnotatedPath> l;
		std::list<AnnotatedPath>::iterator it1;
		l = (*it).second;
		for (it1 = l.begin(); it1 != l.end(); it1++) {
			delete [] (*it1).bPath.bnPP;
		} 
		l.clear();
	}

	ht.clear();
	delete [] uiNodeFrequencyP;
	delete [] lSuccessorFreqP;
}

	/* Another helper function. Increments the edge frequency count.
		 Inputs:
		   uiSrc       -> Source node of the edge
			 uiTarget    -> Target node 
			 uiCount     -> By how much to increment 
		 Return Value:
		   None
		 Side Effects:
		   Increments the edge frequency of the edge (lSuccessorFreqP)
	*/
 void BLPPDB::increment_edge_frequency(unsigned int uiSrc, unsigned int uiTarget,
															 unsigned int uiCount) {
	/* Index into the source */
	unsigned int uiFound = 0;

	for (std::list<EdgeFreq>::iterator it =
				 lSuccessorFreqP[uiSrc].begin(); it != lSuccessorFreqP[uiSrc].end(); 
			 it++) {
		if ((*it).uiTarget == uiTarget) {
			uiFound = 1;
			(*it).uiFreq = (*it).uiFreq + uiCount;
		}
	}

	if (0 == uiFound) {
		/* First time this edge is taken. Initialize! */
		EdgeFreq efTemp;
		efTemp.uiTarget = uiTarget;
		efTemp.uiFreq = uiCount;
		lSuccessorFreqP[uiSrc].push_back(efTemp);
	}
}



BLPPDB::~BLPPDB() {
	delete [] bhP;
	fclose(fDBP);
}

char BLPPDB::ID = 0;
static RegisterPass<BLPPDB> BLPPDBRegistration("blpp_db", "analyze path profile");

